# 要闻

每个线程都可以独立的设置信号掩码，在进程信号掩码的函数为sigprocmask，但是在多线程环境下我们应该使用如下所示的pthread版本的sigprocmask函数来设置信号掩码：
```c++
    #inlcude<pthread.h>
    #include<signal.h>
    int pthread_sigmask(int how,const sigset_t* newmask,sigset_t* oldmask);
```

由于进程中所有线程共享该进程的信号，所以线程库将根据线程掩码决定把信号发送给哪个具体的线程，因此，如果我们在子线程中单独的设置信号掩码，就很容易导致逻辑错误。同时，所有的线程都共享信号处理函数，也就是说，当我们一个线程中设置了某个信号的信号处理函数之后，它会覆盖其他线程同一个信号设置的信号处理函数。

## 如何定义一个专门的线程来处理所有的信号：

    - 在主线程创建其他线程之前就调用pthread_sigmask来设置好信号掩码，所有的新创建的子线程都将继承这个信号掩码。这样做之后，所有线程都不会响应被屏蔽的信号了。

    - 在某个线程中调用如下函数来等待信号并处理之：
        ```c++
            #include<signal.h>
            int sigwait(const sigset_t* set,int sig);
        ```

## 判断目标线程是否存在

```c++
    #include<signal.h>
    int pthread_kill(pthread_t thread,int sig);
```
其中，thread参数指定目标线程，sig参数指定带发送的信号，如果sig为0，则pthread_kill不发送信号，但它会执行错误检查，我们可以利用这种方式来检测目标线程是否存在，pthread_kill成功则返回0，失败就返回错误码，