### 多进程编程

进程是linux操作系统环境的基础，它控制着系统上几乎所有的活动。

1. 拷贝进程映像的`fork`系统调用和替换进程映像的`exec`系列系统调用。
2. 僵尸进程以及如何避免僵尸进程。
3. 进程间通信
4. 在进程传递fd的方法，通过`unix`本地域`socket`传递特殊的辅助数据。


#### fork系统调用

linux下创建新的进程的系统调用是fork，
```
	#include<sys/types.h>
	#include<unistd.h>

	pit_t fork(void);

```
该函数的每次调用都会返回2次，在父进程中返回的是子进程的`pid`，在子进程中返回0.所以我们根据返回值可以判断当前进程是`parent`还是`child`。`fork`失败的时候返回-1，并且设置`errno`。

`fork`拷贝当前进程，并在内核进程表中创建一个新的进程表项，新的进程表项有很多属性和`parent`进程相同，比如堆指针、栈指针、和标志寄存器中的值，但也有很多属性被赋予了新的值，比如该进程的`ppid`被设置为`parent`的`pid`,信号位图被清除(`parent`设置的信号处理函数不再对新的进程起作用)。`fork`调用之后，子进程将继承父进程的信号掩码，但是具有一个空的挂起信号集。

子进程和父进程完全相同，同时它还是拷贝父进程的的数据(堆数据、栈数据、静态数据)。数据的拷贝采用的都是写时拷贝(copy on write)，即只有在子进程对数据执行了写操作的时候，copy才会发生。即使如此，如果我们在程序中分配了大量的内存，那么使用`fork`也应当十分的谨慎，尽量避免内存分配和数据拷贝。

此外，创建子进程之后，父进程中打开的文件描述符默认在子进程中打开，且文件描述符的引用计数+1.不仅如此，父进程中的根目录，当前工作目录等变量的引用计数均会+1。


#### 处理僵尸进程
对于多进程程序而言，父进程一般需要跟踪子进程的退出状态。因此，当子进程结束运行的时候，内核不会立即释放该进程的进程表表项，以满足父进程后续对子进程退出信息的查询(如果父进程还在运行)，在子进程结束之后，父进程读取其退出状态之前，我们称其子进程处于僵尸状态。
可见，如果父进程没有正确的处理子进程的返回信息，子进程都将处于僵尸状态，并占据内存资源，这是绝对不允许的，毕竟内存资源是有限的。所以才有下列函数来等待子进程结束。
```
#include<sys/types.h>
#include<sys/wait.h>
pid_t wait(int *stat_loc);
pid_t wait(pid_t pid,int *stat_loc,int option);
```
同时，在`sys/wait.h`头文件中定义了几个宏来帮助解释子进程的退出状态信息。
`wait`的阻塞特性显然不是服务器程序期望的行为，而`waitpid`解决了这个问题，`waitpid`只等待由`pid`参数指定的子进程。同时，`option`取值是`WNOHANG`时，`waitpid`调用将是非阻塞的：如果`pid`指定的目标子进程还没有结束或者意外终止，则`waitpid`立即返回0；如果目标子进程确实正常退出了，则`waitpid`返回该子进程的`pid`.`waitpid`调用失败时返回-1，并设置`errno`。在事件发生之后的情况下执行非阻塞的调用能提高应用程序的效率，对吧？
当一个进程结束的时候，它将父进程发送一个`SIGCHLD`的信号，因此我们在父进程中捕获该信号，并在信号处理函数中调用`waitpid`函数来彻底的结束一个子进程。
```
//sigchld信号的典型处理函数
static void handle_child(int sig)
{
	pid_t pid;
	int stat;
	while((pid=waitpid(-1,&stat,WNOHANG))>0){//如果目标子进程确实正常退出了，则`waitpid`返回该子进程的`pid`.则进行善后处理。
	//对结束的子进程善后处理
	}
}

```

#### 在进程之间传递文件描述符
由于在`fork`调用之后，父进程打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便的从父进程传递到子进程。需要注意的是，传递一个文件描述符并不是传递一个文件描述符的value，而是要在接收进程中创建一个新的文件描述符表项，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。
那么如何把子进程中打开的文件描述符传递给父进程中呢？或者更加通俗的说，如何在2个不相干的进程之间传递文件描述符呢？在linxu下，我们可以利用unix域socket在进程间传递特殊的辅助数据，以实现文件描述符的传递。
